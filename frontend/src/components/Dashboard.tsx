/**
 * Main Dashboard component for real-time meeting transcription display
 */
import React, { useState, useEffect, useCallback, useRef } from 'react';\nimport {\n  Box,\n  Grid,\n  Paper,\n  Typography,\n  Button,\n  Card,\n  CardContent,\n  Chip,\n  LinearProgress,\n  Alert,\n  Snackbar,\n  Dialog,\n  DialogTitle,\n  DialogContent,\n  DialogActions,\n  TextField,\n  IconButton,\n  Tooltip,\n  Badge,\n} from '@mui/material';\nimport {\n  PlayArrow,\n  Stop,\n  Settings,\n  Info,\n  Person,\n  Psychology,\n  MenuBook,\n  Schedule,\n  Warning,\n  CheckCircle,\n  Error as ErrorIcon,\n} from '@mui/icons-material';\nimport { PieChart, Pie, Cell, ResponsiveContainer, LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip as RechartsTooltip, Legend } from 'recharts';\nimport moment from 'moment';\n\nimport { webSocketService, ChunkData, MeetingSummary } from '../services/websocketService';\nimport { apiService, StartSessionRequest } from '../services/apiService';\n\ninterface DashboardState {\n  isConnected: boolean;\n  currentSession: string | null;\n  sessionStatus: 'idle' | 'starting' | 'active' | 'stopping' | 'completed' | 'error';\n  chunks: ChunkData[];\n  finalSummary: MeetingSummary | null;\n  statusMessages: string[];\n  error: string | null;\n  sessionStats: {\n    totalChunks: number;\n    totalDuration: number;\n    currentChunk: number;\n  };\n}\n\nconst COLORS = ['#8884d8', '#82ca9d', '#ffc658', '#ff7300', '#00ff00'];\n\nconst Dashboard: React.FC = () => {\n  const [state, setState] = useState<DashboardState>({\n    isConnected: false,\n    currentSession: null,\n    sessionStatus: 'idle',\n    chunks: [],\n    finalSummary: null,\n    statusMessages: [],\n    error: null,\n    sessionStats: {\n      totalChunks: 0,\n      totalDuration: 0,\n      currentChunk: 0,\n    },\n  });\n\n  const [showStartDialog, setShowStartDialog] = useState(false);\n  const [sessionName, setSessionName] = useState('');\n  const [showError, setShowError] = useState(false);\n  const chunksEndRef = useRef<HTMLDivElement>(null);\n\n  // Auto-scroll to latest chunk\n  const scrollToBottom = useCallback(() => {\n    chunksEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, []);\n\n  useEffect(() => {\n    scrollToBottom();\n  }, [state.chunks, scrollToBottom]);\n\n  // Initialize WebSocket connection\n  useEffect(() => {\n    const initializeConnection = async () => {\n      try {\n        await webSocketService.connect();\n        \n        webSocketService.onConnected(() => {\n          setState(prev => ({ ...prev, isConnected: true, error: null }));\n        });\n\n        webSocketService.onDisconnected(() => {\n          setState(prev => ({ ...prev, isConnected: false }));\n        });\n\n        webSocketService.onChunkUpdate((sessionId, chunk) => {\n          if (sessionId === state.currentSession) {\n            setState(prev => ({\n              ...prev,\n              chunks: [...prev.chunks, chunk],\n              sessionStats: {\n                ...prev.sessionStats,\n                totalChunks: prev.sessionStats.totalChunks + 1,\n                currentChunk: chunk.chunk_id,\n                totalDuration: chunk.end_time,\n              },\n            }));\n          }\n        });\n\n        webSocketService.onSummaryUpdate((sessionId, summary) => {\n          if (sessionId === state.currentSession) {\n            setState(prev => ({\n              ...prev,\n              finalSummary: summary,\n              sessionStatus: 'completed',\n            }));\n          }\n        });\n\n        webSocketService.onStatusUpdate((sessionId, status, details) => {\n          const message = `${moment().format('HH:mm:ss')}: ${status}`;\n          setState(prev => ({\n            ...prev,\n            statusMessages: [...prev.statusMessages.slice(-4), message], // Keep last 5 messages\n          }));\n\n          if (details?.error) {\n            setState(prev => ({ ...prev, error: status, sessionStatus: 'error' }));\n            setShowError(true);\n          }\n        });\n\n        webSocketService.onError((error) => {\n          setState(prev => ({ ...prev, error, isConnected: false }));\n          setShowError(true);\n        });\n\n      } catch (error) {\n        setState(prev => ({ ...prev, error: `Failed to connect: ${error}`, isConnected: false }));\n        setShowError(true);\n      }\n    };\n\n    initializeConnection();\n\n    return () => {\n      webSocketService.disconnect();\n    };\n  }, [state.currentSession]);\n\n  const handleStartSession = async () => {\n    try {\n      setState(prev => ({ ...prev, sessionStatus: 'starting', error: null }));\n      \n      const request: StartSessionRequest = {\n        session_name: sessionName || undefined,\n        metadata: {\n          started_by: 'dashboard',\n          start_time: new Date().toISOString(),\n        },\n      };\n\n      const response = await apiService.startSession(request);\n      \n      setState(prev => ({\n        ...prev,\n        currentSession: response.session_id,\n        sessionStatus: 'active',\n        chunks: [],\n        finalSummary: null,\n        statusMessages: [],\n        sessionStats: { totalChunks: 0, totalDuration: 0, currentChunk: 0 },\n      }));\n\n      // Subscribe to session updates\n      webSocketService.subscribeToSession(response.session_id);\n      \n      setShowStartDialog(false);\n      setSessionName('');\n\n    } catch (error) {\n      setState(prev => ({ \n        ...prev, \n        error: `Failed to start session: ${error}`,\n        sessionStatus: 'error'\n      }));\n      setShowError(true);\n    }\n  };\n\n  const handleStopSession = async () => {\n    if (!state.currentSession) return;\n\n    try {\n      setState(prev => ({ ...prev, sessionStatus: 'stopping' }));\n      \n      await apiService.stopSession(state.currentSession);\n      \n      // Unsubscribe from session updates\n      webSocketService.unsubscribeFromSession(state.currentSession);\n      \n    } catch (error) {\n      setState(prev => ({ \n        ...prev, \n        error: `Failed to stop session: ${error}`,\n        sessionStatus: 'error'\n      }));\n      setShowError(true);\n    }\n  };\n\n  const getEmotionData = () => {\n    const emotionCounts: Record<string, number> = {};\n    \n    state.chunks.forEach(chunk => {\n      Object.values(chunk.emotions).forEach(emotion => {\n        emotionCounts[emotion.dominant_emotion] = \n          (emotionCounts[emotion.dominant_emotion] || 0) + 1;\n      });\n    });\n\n    return Object.entries(emotionCounts).map(([emotion, count]) => ({\n      name: emotion,\n      value: count,\n    }));\n  };\n\n  const getSpeakerData = () => {\n    const speakerCounts: Record<string, number> = {};\n    \n    state.chunks.forEach(chunk => {\n      chunk.speakers.speakers.forEach(speaker => {\n        speakerCounts[speaker] = (speakerCounts[speaker] || 0) + 1;\n      });\n    });\n\n    return Object.entries(speakerCounts).map(([speaker, count]) => ({\n      name: speaker,\n      value: count,\n    }));\n  };\n\n  const formatDuration = (seconds: number): string => {\n    const mins = Math.floor(seconds / 60);\n    const secs = Math.floor(seconds % 60);\n    return `${mins}:${secs.toString().padStart(2, '0')}`;\n  };\n\n  return (\n    <Box sx={{ flexGrow: 1, p: 3 }}>\n      {/* Header */}\n      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>\n        <Typography variant=\"h4\" component=\"h1\">\n          Meeting Transcription Dashboard\n        </Typography>\n        \n        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>\n          {/* Connection Status */}\n          <Chip\n            icon={state.isConnected ? <CheckCircle /> : <ErrorIcon />}\n            label={state.isConnected ? 'Connected' : 'Disconnected'}\n            color={state.isConnected ? 'success' : 'error'}\n          />\n          \n          {/* Session Controls */}\n          {state.sessionStatus === 'idle' && (\n            <Button\n              variant=\"contained\"\n              startIcon={<PlayArrow />}\n              onClick={() => setShowStartDialog(true)}\n              disabled={!state.isConnected}\n            >\n              Start Session\n            </Button>\n          )}\n          \n          {state.sessionStatus === 'active' && (\n            <Button\n              variant=\"contained\"\n              color=\"error\"\n              startIcon={<Stop />}\n              onClick={handleStopSession}\n            >\n              Stop Session\n            </Button>\n          )}\n          \n          {state.sessionStatus === 'starting' && (\n            <Button variant=\"contained\" disabled>\n              Starting...\n            </Button>\n          )}\n          \n          {state.sessionStatus === 'stopping' && (\n            <Button variant=\"contained\" disabled>\n              Stopping...\n            </Button>\n          )}\n        </Box>\n      </Box>\n\n      {/* Session Info */}\n      {state.currentSession && (\n        <Card sx={{ mb: 3 }}>\n          <CardContent>\n            <Grid container spacing={3}>\n              <Grid item xs={12} md={3}>\n                <Typography variant=\"subtitle2\">Session ID</Typography>\n                <Typography variant=\"body2\" sx={{ fontFamily: 'monospace' }}>\n                  {state.currentSession}\n                </Typography>\n              </Grid>\n              <Grid item xs={12} md={3}>\n                <Typography variant=\"subtitle2\">Duration</Typography>\n                <Typography variant=\"body2\">\n                  {formatDuration(state.sessionStats.totalDuration)}\n                </Typography>\n              </Grid>\n              <Grid item xs={12} md={3}>\n                <Typography variant=\"subtitle2\">Chunks Processed</Typography>\n                <Typography variant=\"body2\">\n                  {state.sessionStats.totalChunks}\n                </Typography>\n              </Grid>\n              <Grid item xs={12} md={3}>\n                <Typography variant=\"subtitle2\">Status</Typography>\n                <Chip \n                  label={state.sessionStatus} \n                  color={state.sessionStatus === 'active' ? 'success' : 'default'}\n                  size=\"small\"\n                />\n              </Grid>\n            </Grid>\n          </CardContent>\n        </Card>\n      )}\n\n      {/* Progress Bar */}\n      {state.sessionStatus === 'active' && (\n        <Box sx={{ mb: 3 }}>\n          <LinearProgress />\n          <Typography variant=\"caption\" sx={{ mt: 1 }}>\n            Processing audio in real-time...\n          </Typography>\n        </Box>\n      )}\n\n      <Grid container spacing={3}>\n        {/* Real-time Transcript */}\n        <Grid item xs={12} lg={8}>\n          <Paper sx={{ p: 2, height: '500px', overflow: 'auto' }}>\n            <Typography variant=\"h6\" gutterBottom>\n              <MenuBook sx={{ mr: 1, verticalAlign: 'middle' }} />\n              Live Transcript\n            </Typography>\n            \n            {state.chunks.length === 0 && (\n              <Box sx={{ textAlign: 'center', mt: 4 }}>\n                <Typography color=\"textSecondary\">\n                  {state.sessionStatus === 'idle' ? 'Start a session to see transcript' : 'Waiting for audio...'}\n                </Typography>\n              </Box>\n            )}\n            \n            {state.chunks.map((chunk, index) => (\n              <Box key={chunk.chunk_id} sx={{ mb: 2, p: 2, bgcolor: 'grey.50', borderRadius: 1 }}>\n                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>\n                  <Typography variant=\"subtitle2\">\n                    Chunk {chunk.chunk_id} ({formatDuration(chunk.start_time)} - {formatDuration(chunk.end_time)})\n                  </Typography>\n                  <Box sx={{ display: 'flex', gap: 1 }}>\n                    {chunk.speakers.speakers.map(speaker => (\n                      <Chip key={speaker} label={speaker} size=\"small\" />\n                    ))}\n                  </Box>\n                </Box>\n                \n                <Typography variant=\"body2\">\n                  {chunk.transcript.full_text}\n                </Typography>\n                \n                {chunk.micro_summary && (\n                  <Typography variant=\"caption\" sx={{ display: 'block', mt: 1, fontStyle: 'italic' }}>\n                    Summary: {chunk.micro_summary}\n                  </Typography>\n                )}\n              </Box>\n            ))}\n            \n            <div ref={chunksEndRef} />\n          </Paper>\n        </Grid>\n\n        {/* Analytics Panel */}\n        <Grid item xs={12} lg={4}>\n          <Grid container spacing={2}>\n            {/* Emotion Analysis */}\n            <Grid item xs={12}>\n              <Paper sx={{ p: 2 }}>\n                <Typography variant=\"h6\" gutterBottom>\n                  <Psychology sx={{ mr: 1, verticalAlign: 'middle' }} />\n                  Emotions\n                </Typography>\n                \n                {getEmotionData().length > 0 ? (\n                  <ResponsiveContainer width=\"100%\" height={200}>\n                    <PieChart>\n                      <Pie\n                        data={getEmotionData()}\n                        cx=\"50%\"\n                        cy=\"50%\"\n                        labelLine={false}\n                        label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}\n                        outerRadius={60}\n                        fill=\"#8884d8\"\n                        dataKey=\"value\"\n                      >\n                        {getEmotionData().map((entry, index) => (\n                          <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />\n                        ))}\n                      </Pie>\n                      <RechartsTooltip />\n                    </PieChart>\n                  </ResponsiveContainer>\n                ) : (\n                  <Typography color=\"textSecondary\">No emotion data yet</Typography>\n                )}\n              </Paper>\n            </Grid>\n\n            {/* Speaker Distribution */}\n            <Grid item xs={12}>\n              <Paper sx={{ p: 2 }}>\n                <Typography variant=\"h6\" gutterBottom>\n                  <Person sx={{ mr: 1, verticalAlign: 'middle' }} />\n                  Speakers\n                </Typography>\n                \n                {getSpeakerData().length > 0 ? (\n                  <ResponsiveContainer width=\"100%\" height={150}>\n                    <PieChart>\n                      <Pie\n                        data={getSpeakerData()}\n                        cx=\"50%\"\n                        cy=\"50%\"\n                        labelLine={false}\n                        label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}\n                        outerRadius={50}\n                        fill=\"#82ca9d\"\n                        dataKey=\"value\"\n                      >\n                        {getSpeakerData().map((entry, index) => (\n                          <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />\n                        ))}\n                      </Pie>\n                      <RechartsTooltip />\n                    </PieChart>\n                  </ResponsiveContainer>\n                ) : (\n                  <Typography color=\"textSecondary\">No speaker data yet</Typography>\n                )}\n              </Paper>\n            </Grid>\n\n            {/* Jargon Terms */}\n            <Grid item xs={12}>\n              <Paper sx={{ p: 2 }}>\n                <Typography variant=\"h6\" gutterBottom>\n                  Technical Terms\n                </Typography>\n                \n                <Box sx={{ maxHeight: 200, overflow: 'auto' }}>\n                  {state.chunks\n                    .flatMap(chunk => chunk.jargon)\n                    .slice(-10) // Show last 10 terms\n                    .map((term, index) => (\n                      <Tooltip key={index} title={term.definition}>\n                        <Chip\n                          label={term.term}\n                          size=\"small\"\n                          sx={{ m: 0.5 }}\n                          clickable\n                        />\n                      </Tooltip>\n                    ))\n                  }\n                  \n                  {state.chunks.length === 0 && (\n                    <Typography color=\"textSecondary\">No technical terms detected yet</Typography>\n                  )}\n                </Box>\n              </Paper>\n            </Grid>\n          </Grid>\n        </Grid>\n      </Grid>\n\n      {/* Final Summary */}\n      {state.finalSummary && (\n        <Paper sx={{ mt: 3, p: 3 }}>\n          <Typography variant=\"h5\" gutterBottom>\n            Meeting Summary\n          </Typography>\n          \n          <Grid container spacing={3}>\n            <Grid item xs={12} md={8}>\n              <Typography variant=\"h6\" gutterBottom>Summary</Typography>\n              <Typography variant=\"body1\">\n                {state.finalSummary.final_summary}\n              </Typography>\n            </Grid>\n            \n            <Grid item xs={12} md={4}>\n              <Typography variant=\"h6\" gutterBottom>Statistics</Typography>\n              <Typography variant=\"body2\">Total Duration: {formatDuration(state.finalSummary.total_duration)}</Typography>\n              <Typography variant=\"body2\">Total Chunks: {state.finalSummary.total_chunks}</Typography>\n              <Typography variant=\"body2\">Speakers: {Object.keys(state.finalSummary.speakers_summary).join(', ')}</Typography>\n            </Grid>\n          </Grid>\n        </Paper>\n      )}\n\n      {/* Status Messages */}\n      {state.statusMessages.length > 0 && (\n        <Paper sx={{ mt: 3, p: 2 }}>\n          <Typography variant=\"h6\" gutterBottom>\n            <Info sx={{ mr: 1, verticalAlign: 'middle' }} />\n            Status\n          </Typography>\n          \n          {state.statusMessages.map((message, index) => (\n            <Typography key={index} variant=\"body2\" sx={{ fontFamily: 'monospace' }}>\n              {message}\n            </Typography>\n          ))}\n        </Paper>\n      )}\n\n      {/* Start Session Dialog */}\n      <Dialog open={showStartDialog} onClose={() => setShowStartDialog(false)}>\n        <DialogTitle>Start New Session</DialogTitle>\n        <DialogContent>\n          <TextField\n            autoFocus\n            margin=\"dense\"\n            label=\"Session Name (Optional)\"\n            fullWidth\n            variant=\"outlined\"\n            value={sessionName}\n            onChange={(e) => setSessionName(e.target.value)}\n            sx={{ mt: 2 }}\n          />\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={() => setShowStartDialog(false)}>Cancel</Button>\n          <Button onClick={handleStartSession} variant=\"contained\">\n            Start Session\n          </Button>\n        </DialogActions>\n      </Dialog>\n\n      {/* Error Snackbar */}\n      <Snackbar\n        open={showError}\n        autoHideDuration={6000}\n        onClose={() => setShowError(false)}\n      >\n        <Alert severity=\"error\" onClose={() => setShowError(false)}>\n          {state.error}\n        </Alert>\n      </Snackbar>\n    </Box>\n  );\n};\n\nexport default Dashboard;